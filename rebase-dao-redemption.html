<!-- Rebase DAOs redemption (50/50) simulator -->
<!-- Date of creation: 2021-12-18 -->
<!-- v0.7.0 -->

<head>
<meta charset="utf-8">
<link rel="stylesheet" href="https://unpkg.com/@iooxa/article/dist/iooxa.css">
<script src="https://unpkg.com/@iooxa/article"></script>
<style>
#main {
    margin: 3em;
    margin-top: 2em;
    font-size: 110%;
}
h1 {
    font-size: 1.4em;
}
h2 {
    font-size: 1.1em;
}
section {
    border-bottom: black dashed 1px;
    padding-bottom: 1em;
    margin-bottom: 1em;
}
r-input, input, mwc-textfield, .mdc-floating-label, .mdc-floating-label--float-above, .mdc-text-field--filled {
    font-size: 130% !important;
}
body {
    --mdc-typography-subtitle1-font-size: 100%;
}

.flex-row-container {
    background: #aaa;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
}
.flex-row-container > .flex-row-item {
    flex: 1 1 30%; /*grow | shrink | basis */
    height: 100px;
    text-align: center;
}

.flex-row-item {
  background-color: #fff4e6;
  border: 1px solid #f76707;
}
</style>
</head>

<body>
<div id="main">
<article>
<h1>Spartacus Redemption (50/50) Simulator</h1>
<h2>version: 0.7.0</h2>
<br/>

<r-scope name="varscope">
    <!-- Vars def -->
    <!-- Initial state memory (copy values here from supply and rfvtreasury) -->
    <r-var name="initsupply" value="1000" type="Number" format=".0f"></r-var>
    <r-var name="initrfvtreasury" value="30000" type="Number" format=".0f"></r-var>
    <r-var name="initrfvbackingprice" :value="initrfvtreasury/initsupply" type="Number" format=".2f"></r-var>
    <r-var name="initammreserveSPA" value="1000" type="Number" format=".2f"></r-var>
    <r-var name="initammreserveDAI" value="10000" type="Number" format=".2f"></r-var>
    <r-var name="initspotprice" :value="initammreserveDAI/initammreserveSPA" type="Number" format=".2f"></r-var>
    <!-- Market (outside of the protocol) parameters -->
    <r-var name="ammreserveSPA" value="1000" type="Number" format=".2f"></r-var>
    <r-var name="ammreserveDAI" value="10000" type="Number" format=".2f"></r-var>
    <r-var name="ammfee" value="0.3" type="Number" format=".2f"></r-var>
    <r-var name="amountspaout" :value="((1-ammfee/100)*amountdaibuy*ammreserveSPA)/(ammreserveDAI+(1-ammfee/100)*amountdaibuy)" type="Number" format=".2f"></r-var> <!-- Simulation of Uniswap constant product + fee swap, kudos to Troughkin! -->
    <r-var name="amountspaoutnofee" :value="(amountdaibuy*ammreserveSPA)/(ammreserveDAI+amountdaibuy)" type="Number" format=".2f"></r-var> <!-- to maintain k constant, we do not account for the fee when subtracting the amount to the reserve, simulating how the fees are withdrawing from the pool to give to LP token holders -->
    <r-var name="amountdaiout" :value="((1-ammfee/100)*amountsparedeem*ammreserveDAI)/(ammreserveSPA+(1-ammfee/100)*amountsparedeem)" type="Number" format=".2f"></r-var>
    <r-var name="amountdaioutnofee" :value="(amountsparedeem*ammreserveDAI)/(ammreserveSPA+amountsparedeem)" type="Number" format=".2f"></r-var>
    <!-- Protocol's parameters, will be dynamically updated -->
    <r-var name="supply" value="1000" type="Number" format=".0"></r-var>
    <r-var name="rfvtreasury" value="30000" type="Number" format=".0f"></r-var>
    <r-var name="spotprice" :value="ammreserveDAI/ammreserveSPA" type="Number" format=".2f"></r-var>
    <r-var name="redeemthreshold" value="50" type="Number" format=".2f"></r-var>
    <r-var name="redeemmaxsize" value="10000" type="Number" format=".0f"></r-var>
    <!-- Derivative metrics -->
    <r-var name="rfvbackingprice" :value="rfvtreasury/supply" type="Number" format=".2f"></r-var>
    <r-var name="redeemprice" :value="((rfvbackingprice-spotprice) * redeemthreshold/100) + spotprice" type="Number" format=".2f"></r-var>
    <!-- User settings/holdings -->
    <r-var name="userholdingsSPA" value="100" type="Number" format=".2f"></r-var>
    <r-var name="userholdingsDAI" value="0" type="Number" format=".2f"></r-var>
    <r-var name="userholdingsUSDtotal" :value="userholdingsSPA*spotprice + userholdingsDAI" type="Number" format=".2f"></r-var>
    <r-var name="amountsparedeem" value="0" type="Number" format=".2f"></r-var>
    <r-var name="amountdaibuy" value="0" type="Number" format=".2f"></r-var>

    <h2>Presentation</h2>
    <div>
        <p>
            This is a simulation for a redemption mechanism for the protocol to buy back SPA tokens at a "redemption price" between the RFV Backing Price and the Spot Price, when the spot price is lower than the RFV Backing Price. The goal is to provide a better incentive than selling, while being profitable for both the protocol and the user. For the user, the goal is to get more stablecoin value by redemption than by selling. For the protocol, the goal is to lose less treasury than it gains RFV Backing Price appreciation (ie, by buying back and hence burning more tokens for the same amount of treasury).
        </p>
    </div>

    <!-- Dashboard -->
    <h2>Dashboard</h2>
    <div class="flex-row-container">
        <p class="flex-row-item">Risk-Free Value (RFV) Backing per SPA<br/>$<r-display :value="rfvbackingprice" format=".2f"></r-display></p>
        <p class="flex-row-item">SPA Spot Price<br/>$<r-display :value="spotprice" format=".2f"></r-display></p>
        <p class="flex-row-item">Redeem Price<br/>$<r-display :value="redeemprice" format=".2f"></r-display></p>
        <p class="flex-row-item">Supply<br/><r-display :value="supply" format=".0f"></r-display> SPA</p>
        <p class="flex-row-item">RFV treasury<br/>$<r-display :value="rfvtreasury" format=".0f"></r-display></p>
    </div>

    <!-- Control board -->
    <h2>Simulation</h2>
    <table>
    <thead>
        <tr>
            <th>Redemption/Sell</th>
            <th>Buy</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <div style="display: flex; flex-direction: column">
                    <r-input label="Redeem Threshold % (admin setting)" :value="redeemthreshold" :change="{redeemthreshold: parseFloat(value)}"></r-input>
                    <r-input label="Redeem Max Size (admin setting)" :value="redeemmaxsize" :change="{redeemmaxsize: parseFloat(value)}"></r-input>
                    <br/><div>
                            <r-input label="Amount of SPA to redeem or sell" :value="amountsparedeem" :change="{amountsparedeem: (value <= redeemmaxsize) ? parseFloat(value) : parseFloat(redeemmaxsize)}"></r-input>
                            <br/>
                            <r-button label="25%" outlined="" :click="{amountsparedeem: ((userholdingsSPA * 0.25) <= redeemmaxsize) ? (userholdingsSPA * 0.25) : redeemmaxsize}"></r-button>
                            <r-button label="50%" outlined="" :click="{amountsparedeem: ((userholdingsSPA * 0.5) <= redeemmaxsize) ? (userholdingsSPA * 0.5) : redeemmaxsize}"></r-button>
                            <r-button label="75%" outlined="" :click="{amountsparedeem: ((userholdingsSPA * 0.75) <= redeemmaxsize) ? (userholdingsSPA * 0.75) : redeemmaxsize}"></r-button>
                            <r-button label="MAX" outlined="" :click="{amountsparedeem: (userholdingsSPA <= redeemmaxsize) ? userholdingsSPA : redeemmaxsize}"></r-button>
                        </div>
                    <br/><div>
                            <r-button id="redeembtn" label="Redeem" outlined="true" :click="{supply: supply-amountsparedeem, userholdingsSPA: userholdingsSPA-amountsparedeem, rfvtreasury: rfvtreasury-(amountsparedeem*redeemprice), userholdingsDAI: userholdingsDAI+amountsparedeem*redeemprice, amountsparedeem: 0}" onclick="checkRedemptionDone();"></r-button>
                            <r-button label="Sell" outlined="true" :click="{userholdingsSPA: userholdingsSPA-amountsparedeem, userholdingsDAI: userholdingsDAI+amountdaiout, ammreserveDAI: ammreserveDAI-amountdaioutnofee, ammreserveSPA: ammreserveSPA+amountsparedeem, amountsparedeem: 0}" onclick="checkRedemptionDone();"></r-button>
                            <p>You will get <r-display :value="amountsparedeem*redeemprice"></r-display> DAI by redeeming
                            <br/>or <r-display :value="amountdaiout"></r-display> DAI by selling <r-display :value="amountsparedeem"></r-display> SPA.</p>
                        </div>
                </div>
            </td>
            <td>
                <div>
                    <p>SPA in reserve: <r-dynamic bind="ammreserveSPA" max="11000000" step="100" sensitivity="0.01"></r-dynamic>, DAI in reserve: <r-dynamic bind="ammreserveDAI" max="11000000" step="100" sensitivity="0.01"></r-dynamic></p>
                    <r-input label="Amount of DAI to spend to buy" :value="amountdaibuy" :change="{amountdaibuy: parseFloat(value)}"></r-input>
                    <br/><r-button label="Max" outlined="" :click="{amountdaibuy: userholdingsDAI}"></r-button>
                    <r-button label="Buy" outlined="true" :click="{userholdingsSPA: userholdingsSPA+amountspaout, userholdingsDAI: userholdingsDAI-amountdaibuy, ammreserveDAI: ammreserveDAI+amountdaibuy, ammreserveSPA: ammreserveSPA-amountspaoutnofee, amountdaibuy: 0}" onclick="checkRedemptionDone();"></r-button> <!-- userholdingsSPA: userholdingsSPA+amountspabuy is false! It doesn't account for slippage because the k constant between the two tokens reserves would not be maintained constant! -->
                    <p>You will get <r-display :value="amountspaout" format=".2f"></r-display> SPA with a <r-dynamic bind="ammfee" max="100" format=".2f" step="0.005" sensitivity="0.001"></r-dynamic>%.
                <div>
            </td>
        </tr>
        <tr>
            <td colspan="2">
                <r-button label="Reset simulation with toy data" outlined="true" :click="{initsupply: 1000, initrfvtreasury: 30000, supply: initsupply, rfvtreasury: initrfvtreasury, userholdingsSPA: 100, userholdingsDAI: 0, amountsparedeem: 0, initammreserveDAI: 10000, initammreserveSPA: 1000, ammreserveDAI: 10000, ammreserveSPA: 1000}" onclick="checkRedemptionDone();"></r-button>
                <r-button label="Reset simulation with real data (snapshot on 2021-12-19 with reduced spot price to enable redemption)" outlined="true" :click="{initsupply: 1234403, initrfvtreasury: 47919549, supply: 1234403, rfvtreasury: 47919549, userholdingsSPA: 1079901, userholdingsDAI: 0, amountsparedeem: 0, initammreserveDAI: 6542121, initammreserveSPA: 298738, ammreserveDAI: 6542121, ammreserveSPA: 298738}" onclick="checkRedemptionDone();"></r-button> <!-- values from dexscreener.com and spartacus.finance dashboard and https://info.spookyswap.finance/pair/0xfa5a5f0bc990be1d095c5385fff6516f6e03c0a7 -->
                <!-- userholdingsSPA is set to the circulating supply of SPA, the rest being owned by the protocol -->
            </td>
        </tr>
    </tbody>
    </table>

    <div>
    <h2>Account</h2>
    <p>Your holdings: <r-display :value="userholdingsSPA" format=".2f"></r-display> SPA, <r-display :value="userholdingsDAI" format=".2f"></r-display> DAI, <r-display :value="userholdingsUSDtotal" format=".2f"></r-display> USD in total (SPA at spot price + DAI).</p>
    <p>
        Protocol loss of RFV treasury compared to initial state: <r-display :value="(initrfvtreasury-rfvtreasury)/initrfvtreasury * 100" format=".2f"></r-display>%.
        <br/>Protocol gain of RFV Backing Price compared to initial state: <r-display :value="(rfvbackingprice-initrfvbackingprice)/initrfvbackingprice * 100" format=".2f"></r-display>%.
        <br/>Spot Price growth compared to initial state: <r-display :value="(spotprice-initspotprice)/initspotprice * 100" format=".2f"></r-display>%.
    </p>
    <r-var name="fracrfvtreasury" :value="(rfvtreasury/initrfvtreasury)" type="Number" format=".4f"></r-var>
    <r-var name="fracrfvbackingprice" :value="(rfvbackingprice/initrfvbackingprice)" type="Number" format=".4f"></r-var>
    <r-var name="fracrfvtreasurytorecover" :value="1/fracrfvtreasury" type="Number" format=".4f"></r-var>
    <r-var name="rfvgrowthratio" :value="fracrfvbackingprice/fracrfvtreasurytorecover" type="Number" format=".4f"></r-var> <!-- equivalent alternative: fracrfvtreasury*fracrfvbackingprice -->
    <r-var name="fracspotprice" :value="(spotprice/initspotprice)" type="Number" format=".4f"></r-var>
    <r-var name="rfvspotgrowthratio" :value="fracspotprice/fracrfvtreasurytorecover" type="Number" format=".4f"></r-var>
    <p>
        RFV treasury growth necessary to recover initial state: <r-display :value="fracrfvtreasurytorecover" format=".4f"></r-display>x
        <br/>versus RFV Backing Price growth over initial state: <r-display :value="fracrfvbackingprice" format=".4f"></r-display>x
        <br/>and Spot Price growth over initial state: <r-display :value="fracspotprice" format=".4f"></r-display>x
        <br/>hence <strong>a BackingPrice/Treasury growth ratio of <r-display :value="rfvgrowthratio" format=".4f"></r-display>x</strong> (i.e., RFV Backing Price grows <r-display :value="rfvgrowthratio" format="0.4f"></r-display>x faster than the RFV Treasury declines, which is equivalent to RFV Treasury declining at <r-display :value="1/rfvgrowthratio" format="0.4f"></r-display>x compared to RFV Backing Price growth).
        <br/>Explanation: a &lt;1 value indicates a faster rate of decline of RFV Treasury compared to a slower rate of RFV Backing Price growth (this is bad), and a &gt;1 value indicates a faster growth of RFV Backing Price compared to a slower decline of RFV Treasury (this is good, it means the protocol bought and burnt SPA at a discount).
        <br/>We also have <strong>a SpotPrice/Treasury growth ratio of <r-display :value="rfvspotgrowthratio" format=".4f"></r-display>x</strong>.
    </p>
    </div>

    <div>
    <h2>Tips</h2>
    <ul>
        <li>The redeem threshold is a crucial parameter, it defines the redeem price offered relative to the distance between the RFV backing price and (lower) spot price, with 0% the redeem price = spot price, and 100% the redeem price = RFV backing price. The spot price is necessarily lower than the RFV Backing Price for the redemption to work. Try 50% for a null growth rate (ie, the protocol does not lose nor profit with redemption), or &lt;50% for a positive growth rate (ie, the protocol profits by buying SPA back at a discount compared to treasury). Obviously, with &gt;50%, the protocol obtains a negative growth rate, which means it loses more treasury than it increases the RFV Backing Price, which means it buys SPA back at a premium. With 100% (no Redeem Threshold, Redeem Price = RFV Backing Price), the RFV Backing Price stays the same, this is when the protocol loses the most.</li>
        <li>There is no check of account balance, so that you can "overborrow" and get into negative holdings, which will mess up the model :-) Checks could be implemented but it would complexify code much more, so please just don't do that!</li>
        <li>In general, if you get a negative value anywhere, then something went wrong and the result should not be relied upon, you should reset the simulation by refreshing the page!</li>
    </li>
    </div>
    
    <div>
    <h2>Short analysis: one redemption</h2>
    <p>
        Protocol view: Offering a &lt;50% redemption rate allows the protocol to buy back via redemption more tokens and hence increase the RFV Backing Price more than it loses RFV Treasury. Since it is in net profit (ie, it buys back at a discount compared to the backing it has in treasury), redemption acts as an antidilution mechanism during contraction phases (ie, when spot price drops). The redemption threshold is crucial, as 50% allows for an equivalent exchange between RFV Backing Price and RFV Treasury, and thresholds &lt;50% increase the RFV Backing Price faster than the RFV Treasury gets depleted, hence ending up being a net profit for the protocol. This shows that redemption can be an elegant automated solution to counterbalance the dilution produced by staking and bonding durin expansionary phases. Redeem Max Size is unnecessary with one iteration of a redemption.
    </p>
    <p>
        Users view: users who want to exit are always incentivized to use redemption during contraction phases, since they will always get a better redemption price than spot price. Arbitrageur can also buy the token on the market since the spot price is lower than the redemption price, to then do a redemption from the protocol, which is a net profit for them, and allows to raise the spot price on the market.
    </p>

    <h2>Short analysis: redemption/buy loops</h2>
    <p>
        Arbitrageurs are likely to take profit from this opportunity, by looping between redemption and then buying back SPA on the market before doing another redemption etc, increasing their stack of SPA or their DAI balance along the way at each step. In theory, we would expect that allowing a maximum of SPA to be redeemed in one go would be better, since redeeming leads to buying and hence to rising spot price and hence a higher redeeming price, which is less favorable for the protocol. To test whether this is true or not, a Max Redeem Size was implemented, and a liquidity market between SPA/DAI is simulated (which allows for Sell and Buy actions).
    </p>
    <p>
        Set the Max Redeem Size to a huge value, then try to loop redemption then buying then redemption etc until redemption gets disabled (when Spot Price &ge; RFV Backing Price). Although redemption works easily when a single redemption is done and the redemption threshold is set at &lt;50%, looping redemption/buy offsets the balance and the protocol ends up depleting the treasury faster than the RFV Backing Price increases, but both remain at reasonable levels ($23,000 remaining RFV Treasury and RFV Backing Price at ~$33). Interestingly, any value below or higher than 50% depletes the treasury more, and increases the RFV Backing Price less, than a 50% threshold, which suggests that per Romo's model, 50% is the optimal Redeem Threshold when there are redemption/buy loops by arbitrageurs.
    </p>
    <p>
        Note that in an earlier version of this document, it was said that redemption looping could almost fully deplete the treasury. This was due to a refresh bug, which caused the check for redemption to be only done at redemption, but not at buy or sell. This bug allowed to activate redemption when it should have been disabled. This is akin to an Oracle Attack, which suggests that it is of the utmost importance that the Oracle providing the spot price for SPA should be very accurate and up-to-date, to avoid undue redemptions that could deplete the treasury. A safeguard is to set a Max Redeem Size, so as to limit the damage in case this happens.
    </p>
    <p>
        Now set the Max Redeem Size to a lower value, e.g., 30 by default in this simulation. Then, try to redeem the max you can, in multiple steps, and then buy all at once (it doesn't matter whether you buy in one or multiple steps, there is no slippage nor fees in this simulation). You will now observe that the RFV Treasury gets slightly more depleted than with a huge (quasi-infinite) Max Redeem Size
    </p>
    <p>
        Now try another experiment with Max Redeem Size: try to set it at a lower value like before, such as 30, but now try to interleave each redemption with a buy, to simulate arbitrageurs buying on the market in parallel to arbitrageurs who already own SPA and are redeeming. You will notice that we end up with a slightly more depleted RFV Treasury, and a slightly less increased RFV Backing Price. This confirms our initial intuition that Redemption is more profitable to the protocol if done in bulk, because afterwards the Redeeming Price rises and hence it becomes more and more profitable for arbitrageurs.
    </p>
    <p>
        Hence, Max Redeem Size is not a crucial parameter and actually counterproductive for the Redemption mechanism to work, but it still be interesting to implement but with a high value as a safeguard mechanism against potential Oracle Attacks.
    </p>
    <p>
        In conclusion, this simulation identified one key risk of uncontrolled redeeming: the risk of almost complete treasury depletion, which happens only during an Oracle Attack. And two key parameters were identified for a more controlled and favorable redeeming mechanism: 1- Redeem Threshold (optimal value appearing to be 50% exactly), which defines the Redeem Price in-between the spot price and RFV Backing Price ; 2- An up-to-date Oracle to avoid abuse of Redeeming when it should be disabled.
    </p>
    <p>
        It's worth noting that although this simulation only uses the RFV Treasury and RFV Backing Price, which are much easier to model since they only include the DAI stablecoin, the model can likely also apply to the Standalone Treasury (stablecoins + volatile assets like FTM but without LP tokens), see Credits for more infos on these other models.
    </p>
    </div>
    
    <div>
    <h2>Credits</h2>
    <ul>
        <li>This simulation was coded by Kromer for the Spartacus.finance protocol.</li>
        <li>Many thanks to Romo who had the original idea to define a redemption threshold, which inspired this simulation, with the difference that their proposal was on the total treasury value instead of RFV treasury value (hence also including FTM and LP tokens) and that the Redeemable Threshold is configurable, with the assumption that &lt;50% may be more profitable for the protocol (which is false, 50% is optimal, see the Short Analysis sections for more details). Their spreadsheet, which show the same results, can be found here: <a href="https://discord.com/channels/901810422590627880/920429601338044466/921554042021371914">https://discord.com/channels/901810422590627880/920429601338044466/921554042021371914</a></li>
        <li>Kudos to anirudhab and Looser Spartan for their <a href="https://discord.com/channels/901810422590627880/902138528614469653/920898911479136266">initial suggestion</a> of a redemption mechanism inspired by ETFs, which in turns inspired Romo's suggestion and this simulation. More precisely, they proposed to use the Standalone treasury value (stablecoin + FTM, but not LP tokens).</li>
        <li>Thanks to Troughkin for his help in determining the equation for simulating the price change after buying using AMM's equation.</li>
    </ul>
    </div>
    
    <div>
    <h2>Source code</h2>
    <p>The source code under MIT License is at: <a href="https://github.com/satoreph/spartacus-dao-redemption-sim">https://github.com/satoreph/spartacus-dao-redemption-sim</a></p>
    <p>You can download the HTML file to run locally and more variables can be changed in the source code.</p>
    </div>

</r-scope>
</article>
</div>

<script>
    function checkRedemptionDone() {
        // Checks if RFV Backing Price < Spot Price, then we disable redemption
        let rfvbackingprice = iooxa.getVariableByName('varscope.rfvbackingprice').get();
        let spotprice = iooxa.getVariableByName('varscope.spotprice').get();
        if (spotprice >= rfvbackingprice) {
            const redeembtn = document.getElementById('redeembtn');
            redeembtn.disabled = 'true';
        } else {
            const redeembtn = document.getElementById('redeembtn');
            redeembtn.disabled = 'false';
        }
    }

</script>

</body>