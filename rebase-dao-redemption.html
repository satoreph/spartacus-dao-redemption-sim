<!-- Rebase DAOs redemption (50/50) simulator -->
<!-- Date of creation: 2021-12-18 -->
<!-- v0.6.1 -->

<head>
<meta charset="utf-8">
<link rel="stylesheet" href="https://unpkg.com/@iooxa/article/dist/iooxa.css">
<script src="https://unpkg.com/@iooxa/article"></script>
<style>
#main {
    margin: 3em;
    margin-top: 2em;
    font-size: 110%;
}
h1 {
    font-size: 1.4em;
}
h2 {
    font-size: 1.1em;
}
section {
    border-bottom: black dashed 1px;
    padding-bottom: 1em;
    margin-bottom: 1em;
}
r-input, input, mwc-textfield, .mdc-floating-label, .mdc-floating-label--float-above, .mdc-text-field--filled {
    font-size: 130% !important;
}
body {
    --mdc-typography-subtitle1-font-size: 100%;
}

.flex-row-container {
    background: #aaa;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
}
.flex-row-container > .flex-row-item {
    flex: 1 1 30%; /*grow | shrink | basis */
    height: 100px;
    text-align: center;
}

.flex-row-item {
  background-color: #fff4e6;
  border: 1px solid #f76707;
}
</style>
</head>

<body>
<div id="main">
<article>
<h1>Spartacus Redemption (50/50) Simulator</h1>
<r-scope name="varscope">
    <!-- Vars def -->
    <!-- Initial state memory (copy values here from supply and rfvtreasury) -->
    <r-var name="initsupply" value="1000" type="Number" format=".0f"></r-var>
    <r-var name="initrfvtreasury" value="30000" type="Number" format=".0f"></r-var>
    <r-var name="initrfvbackingprice" :value="initrfvtreasury/initsupply" type="Number" format=".2f"></r-var>
    <!-- Market (outside of the protocol) parameters -->
    <r-var name="ammreserveSPA" value="1000" type="Number" format=".2f"></r-var>
    <r-var name="ammreserveDAI" value="10000" type="Number" format=".2f"></r-var>
    <!-- Protocol's parameters, will be dynamically updated -->
    <r-var name="supply" value="1000" type="Number" format=".0"></r-var>
    <r-var name="rfvtreasury" value="30000" type="Number" format=".0f"></r-var>
    <r-var name="spotprice" :value="ammreserveDAI/ammreserveSPA" type="Number" format=".2f"></r-var>
    <r-var name="redeemthreshold" value="50" type="Number" format=".2f"></r-var>
    <r-var name="redeemmaxsize" value="30" type="Number" format=".0f"></r-var>
    <!-- Derivative metrics -->
    <r-var name="rfvbackingprice" :value="rfvtreasury/supply" type="Number" format=".2f"></r-var>
    <r-var name="redeemprice" :value="((rfvbackingprice-spotprice) * redeemthreshold/100) + spotprice" type="Number" format=".2f"></r-var>
    <!-- User settings/holdings -->
    <r-var name="userholdingsSPA" value="100" type="Number" format=".2f"></r-var>
    <r-var name="userholdingsDAI" value="0" type="Number" format=".2f"></r-var>
    <r-var name="userholdingsUSDtotal" :value="userholdingsSPA*spotprice + userholdingsDAI" type="Number" format=".2f"></r-var>
    <r-var name="amountsparedeem" value="0" type="Number" format=".2f"></r-var>
    <r-var name="amountspabuy" value="0" type="Number" format=".2f"></r-var>

    <h2>Presentation</h2>
    <div>
        <p>
            This is a simulation for a redemption mechanism for the protocol to buy back SPA tokens at a "redemption price" between the RFV Backing Price and the Spot Price, when the spot price is lower than the RFV Backing Price. The goal is to provide a better incentive than selling, while being profitable for both the protocol and the user. For the user, the goal is to get more stablecoin value by redemption than by selling. For the protocol, the goal is to lose less treasury than it gains RFV Backing Price appreciation (ie, by buying back and hence burning more tokens for the same amount of treasury).
        </p>
    </div>

    <!-- Dashboard -->
    <h2>Dashboard</h2>
    <div class="flex-row-container">
        <p class="flex-row-item">Risk-Free Value (RFV) Backing per SPA<br/>$<r-display :value="rfvbackingprice" format=".2f"></r-display></p>
        <p class="flex-row-item">SPA Spot Price<br/>$<r-display :value="spotprice" format=".2f"></r-display></p>
        <p class="flex-row-item">Redeem Price<br/>$<r-display :value="redeemprice" format=".2f"></r-display></p>
        <p class="flex-row-item">Supply<br/><r-display :value="supply" format=".0f"></r-display> SPA</p>
        <p class="flex-row-item">RFV treasury<br/>$<r-display :value="rfvtreasury" format=".0f"></r-display></p>
    </div>

    <!-- Control board -->
    <h2>Simulation</h2>
    <table>
    <thead>
        <tr>
            <th>Redemption/Sell</th>
            <th>Buy</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <div style="display: flex; flex-direction: column">
                    <r-input label="Redeem Threshold % (admin setting)" :value="redeemthreshold" :change="{redeemthreshold: parseFloat(value)}"></r-input>
                    <r-input label="Redeem Max Size (admin setting)" :value="redeemmaxsize" :change="{redeemmaxsize: parseFloat(value)}"></r-input>
                    <br/><div>
                            <r-input label="Amount of SPA to redeem or sell" :value="amountsparedeem" :change="{amountsparedeem: (value <= redeemmaxsize) ? parseFloat(value) : parseFloat(redeemmaxsize)}"></r-input>
                            <br/>
                            <r-button label="25%" outlined="" :click="{amountsparedeem: ((userholdingsSPA * 0.25) <= redeemmaxsize) ? (userholdingsSPA * 0.25) : redeemmaxsize}"></r-button>
                            <r-button label="50%" outlined="" :click="{amountsparedeem: ((userholdingsSPA * 0.5) <= redeemmaxsize) ? (userholdingsSPA * 0.5) : redeemmaxsize}"></r-button>
                            <r-button label="75%" outlined="" :click="{amountsparedeem: ((userholdingsSPA * 0.75) <= redeemmaxsize) ? (userholdingsSPA * 0.75) : redeemmaxsize}"></r-button>
                            <r-button label="MAX" outlined="" :click="{amountsparedeem: (userholdingsSPA <= redeemmaxsize) ? userholdingsSPA : redeemmaxsize}"></r-button>
                        </div>
                    <br/><div>
                            <r-button id="redeembtn" label="Redeem" outlined="true" :click="{supply: supply-amountsparedeem, userholdingsSPA: userholdingsSPA-amountsparedeem, rfvtreasury: rfvtreasury-(amountsparedeem*redeemprice), userholdingsDAI: userholdingsDAI+amountsparedeem*redeemprice, amountsparedeem: 0}" onclick="checkRedemptionDone();"></r-button>
                            <r-button label="Sell" outlined="true" :click="{userholdingsSPA: userholdingsSPA-amountsparedeem, userholdingsDAI: userholdingsDAI+amountsparedeem*spotprice, ammreserveDAI: ammreserveDAI-amountsparedeem*spotprice, ammreserveSPA: ammreserveSPA+amountsparedeem, amountsparedeem: 0}" onclick="checkRedemptionDone();"></r-button>
                            <r-button label="Reset simulation" outlined="true" :click="{supply: initsupply, rfvtreasury: initrfvtreasury, userholdingsSPA: 100, userholdingsDAI: 0, amountsparedeem: 0}"></r-button>
                            <p>You will get <r-display :value="amountsparedeem*redeemprice"></r-display> DAI by redeeming
                            <br/>or <r-display :value="amountsparedeem*spotprice"></r-display> DAI by selling <r-display :value="amountsparedeem"></r-display> SPA.</p>
                        </div>
                </div>
            </td>
            <td>
                <div>
                    <p>SPA in reserve: <r-dynamic bind="ammreserveSPA" max="11000000" step="100" sensitivity="0.01"></r-dynamic>, DAI in reserve: <r-dynamic bind="ammreserveDAI" max="11000000" step="100" sensitivity="0.01"></r-dynamic></p>
                    <r-input label="Amount of SPA to buy" :value="amountspabuy" :change="{amountspabuy: parseFloat(value)}"></r-input>
                    <r-button label="Max" outlined="" :click="{amountspabuy: userholdingsDAI/spotprice}"></r-button>
                    <r-button label="Buy" outlined="true" :click="{userholdingsSPA: userholdingsSPA+amountspabuy, userholdingsDAI: userholdingsDAI-amountspabuy*spotprice, ammreserveDAI: ammreserveDAI+amountspabuy*spotprice, ammreserveSPA: ammreserveSPA-amountspabuy, amountspabuy: 0}" onclick="checkRedemptionDone();"></r-button>
                    <p>You will get <r-display :value="amountspabuy"></r-display> SPA for <r-display :value="amountspabuy*spotprice"></r-display> DAI.
                <div>
            </td>
        </tr>
    </tbody>
    </table>

    <div>
    <h2>Account</h2>
    <p>Your holdings: <r-display :value="userholdingsSPA" format=".2f"></r-display> SPA, <r-display :value="userholdingsDAI" format=".2f"></r-display> DAI, <r-display :value="userholdingsUSDtotal" format=".2f"></r-display> USD in total (SPA at spot price + DAI).</p>
    <p>Protocol loss of RFV treasury compared to initial state: <r-display :value="(initrfvtreasury-rfvtreasury)/initrfvtreasury * 100"></r-display>%.</p>
    <p>Protocol gain of RFV Backing Price compared to initial state: <r-display :value="(rfvbackingprice-initrfvbackingprice)/initrfvbackingprice * 100"></r-display>%.</p>
    <r-var name="fracrfvtreasury" :value="(rfvtreasury/initrfvtreasury)" type="Number" format=".4f"></r-var>
    <r-var name="fracrfvbackingprice" :value="(rfvbackingprice/initrfvbackingprice)" type="Number" format=".4f"></r-var>
    <r-var name="fracrfvtreasurytorecover" :value="1/fracrfvtreasury" type="Number" format=".4f"></r-var>
    <r-var name="rfvgrowthratio" :value="1/(fracrfvtreasurytorecover/fracrfvbackingprice)" type="Number" format=".4f"></r-var>
    <p>RFV treasury growth necessary to recover initial state: <r-display :value="fracrfvtreasurytorecover"></r-display>x
        <br/>versus RFV Backing Price growth over initial state: <r-display :value="fracrfvbackingprice"></r-display>x
        <br/>hence <strong>a growth ratio of <r-display :value="rfvgrowthratio" format=".4f"></r-display>x</strong> (i.e., RFV Backing Price grows <r-display :value="rfvgrowthratio" format="0.4f"></r-display>x faster than the RFV Treasury declines, which is equivalent to RFV Treasury declining at <r-display :value="1/rfvgrowthratio" format="0.4f"></r-display>x compared to RFV Backing Price growth).
        <br/>Explanation: a &lt;1 value indicates a faster rate of decline of RFV Treasury compared to a slower rate of RFV Backing Price growth (this is bad), and a &gt;1 value indicates a faster growth of RFV Backing Price compared to a slower decline of RFV Treasury (this is good, it means the protocol bought and burnt SPA at a discount).</p>
    </div>

    <div>
    <h2>Tips</h2>
    <ul>
        <li>The redeem threshold is a crucial parameter, it defines the redeem price offered relative to the distance between the RFV backing price and (lower) spot price, with 0% the redeem price = spot price, and 100% the redeem price = RFV backing price. The spot price is necessarily lower than the RFV Backing Price for the redemption to work. Try 50% for a null growth rate (ie, the protocol does not lose nor profit with redemption), or &lt;50% for a positive growth rate (ie, the protocol profits by buying SPA back at a discount compared to treasury). Obviously, with &gt;50%, the protocol obtain a negative growth rate, which means it loses more treasury than it increases the RFV Backing Price, which means it buys SPA back at a premium.</li>
        <li>There is no check of account balance, so that you can "overborrow" and get into negative holdings, which will mess up the model :-) Checks could be implemented but it would complexify code much more, so please just don't do that!</li>
    </li>
    </div>
    
    <div>
    <h2>Short analysis: one redemption</h2>
    <p>
        Protocol view: Offering a &lt;50% redemption rate allows the protocol to buy back via redemption more tokens and hence increase the RFV Backing Price more than it loses RFV Treasury. Since it is in net profit (ie, it buys back at a discount compared to the backing it has in treasury), redemption acts as an antidilution mechanism during contraction phases (ie, when spot price drops). The redemption threshold is crucial, as 50% allows for an equivalent exchange between RFV Backing Price and RFV Treasury, and thresholds &lt;50% increase the RFV Backing Price faster than the RFV Treasury gets depleted, hence ending up being a net profit for the protocol. This shows that redemption can be an elegant automated solution to counterbalance the dilution produced by staking and bonding durin expansionary phases. Redeem Max Size is unnecessary with one iteration of a redemption.
    </p>
    <p>
        Users view: users who want to exit are always incentivized to use redemption during contraction phases, since they will always get a better redemption price than spot price. Arbitrageur can also buy the token on the market since the spot price is lower than the redemption price, to then do a redemption from the protocol, which is a net profit for them, and allows to raise the spot price on the market.
    </p>

    <h2>Short analysis: redemption/buy loops</h2>
    <p>
        Arbitrageurs are likely to take profit from this opportunity, by looping between redemption and then buying back SPA on the market before doing another redemption etc, increasing their stack of SPA or their DAI balance along the way at each step.
    </p>
    <p>
        Set the Max Redeem Size to a huge value, then try to loop redemption then buying then redemption etc until redemption gets disabled (when Spot Price &ge; RFV Backing Price). Although redemption works easily when a single redemption is done and the redemption threshold is set at &lt;50%, looping redemption/buy completely offsets the balance and the protocol ends up losing both the treasury and the RFV Backing Price. Hence, although redemption seems like a nice idea with one iteration, if we account for multiple iterations then huge problems arise and the protocol's treasury ends up being completely depleted, with only minor effect on the RFV backing price, only the spot price benefitting and indeed rising above the RFV Backing Price, but with no treasury left. Interestingly, any value below or higher than 50% depletes the treasury more, and increases the RFV Backing Price less, than a 50% threshold, which suggests that per Romo's model, 50% is the optimal Redeem Threshold when there are redemption/buy loops by arbitrageurs. For example, we end up with $3,000 in RFV Treasury if the Redeeming Threshold is set at 100% or 5%, and the maximum we can retain is ~$11,000 with a 50% threshold.
    </p>
    <p>
        Now set the Max Redeem Size to a lower value, e.g., 30 by default in this simulation. Then, try to redeem the max you can, in multiple steps, and then buy all at once (it doesn't matter whether you buy in one or multiple steps, there is no slippage nor fees in this simulation). You will now observe the RFV Treasury doesn't get nearly as much depleted, in fact with a 50% Redeeming Threshold, we retain ~$23,000 in RFV Treasury and $33.28 in RFV Backing Price, which is much better than without a Max Redeem Size! Yet, the protocol is still at a loss in terms of RFV Backing Price growth, with a ratio of 0.85x (i.e., we lost 16% more in RFV Treasury compared to the increase we gained in RFV Backing Price due to redemption looping). This needs to be worked further on to see if there is a set of parameters, or a hidden parameter, that could increase the growth rate more favorably.
    </p>
    <p>
        In conclusion, this simulation identified one key risk of uncontrolled redeeming: the risk of almost complete treasury depletion. And two key parameters were identified for a more controlled and favorable redeeming mechanism: 1- Redeem Threshold (optimal value appearing to be 50% exactly), which defines the Redeem Price in-between the spot price and RFV Backing Price ; 2- Max Redeem Size, which caps the maximum amount of SPA that can be redeemed in one transaction, which allows the protocol to update the treasury and hence the RFV Backing Price between transactions, and this enormously reduces the treasury depletion. This last point is counterintuitive, because we would expect that allowing a maximum of SPA to be redeemed in one go would be better, since redeeming leads to buying and hence to rising spot price and hence a higher redeeming price, which is less favorable for the protocol. But the simulation suggests the opposite happens for some reason.
    </p>
    <p>
        It's worth noting that although this simulation only uses the RFV Treasury and RFV Backing Price, which are much easier to model since they only include the DAI stablecoin, the model can likely also apply to the Standalone Treasury (stablecoins + volatile assets like FTM but without LP tokens), see Credits for more infos on these other models.
    </p>
    </div>
    
    <div>
    <h2>Credits</h2>
    <ul>
        <li>This simulation was coded by Kromer for the Spartacus.finance protocol.</li>
        <li>Many thanks to Romo who had the original idea to define a redemption threshold, which inspired this simulation, with the difference that their proposal was on the total treasury value instead of RFV treasury value (hence also including FTM and LP tokens) and that the Redeemable Threshold is configurable, with the assumption that &lt;50% may be more profitable for the protocol (which is false, 50% is optimal, see the Short Analysis sections for more details). Their spreadsheet, which show the same results, can be found here: <a href="https://discord.com/channels/901810422590627880/920429601338044466/921554042021371914">https://discord.com/channels/901810422590627880/920429601338044466/921554042021371914</a></li>
        <li>Kudos to anirudhab and Looser Spartan for their <a href="https://discord.com/channels/901810422590627880/902138528614469653/920898911479136266">initial suggestion</a> of a redemption mechanism inspired by ETFs, which in turns inspired Romo's suggestion and this simulation. More precisely, they proposed to use the Standalone treasury value (stablecoin + FTM, but not LP tokens).</li>
        <li>Thanks to Troughkin for his help in determining the equation for simulating the price change after buying using AMM's equation.</li>
    </ul>
    </div>
    
    <div>
    <h2>Source code</h2>
    <p>The source code under MIT License is at: <a href="https://github.com/satoreph/spartacus-dao-redemption-sim">https://github.com/satoreph/spartacus-dao-redemption-sim</a></p>
    <p>You can download the HTML file to run locally and more variables can be changed in the source code.</p>
    </div>

</r-scope>
</article>
</div>

<script>
    function checkRedemptionDone() {
        // Checks if RFV Backing Price < Spot Price, then we disable redemption
        let rfvbackingprice = iooxa.getVariableByName('varscope.rfvbackingprice').get();
        let spotprice = iooxa.getVariableByName('varscope.spotprice').get();
        if (spotprice >= rfvbackingprice) {
            const redeembtn = document.getElementById('redeembtn');
            redeembtn.disabled = 'true';
        } else {
            const redeembtn = document.getElementById('redeembtn');
            redeembtn.disabled = 'false';
        }
    }

</script>

</body>